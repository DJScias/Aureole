// Made according to this guide https://zork.net/~st/jottings/sais.html
use std::{cmp::Ordering, borrow::Cow};

trait Value: Ord + Clone + Into<usize> {
	fn i(&self) -> usize {
		self.clone().into()
	}
}
impl Value for u8 {}
impl Value for usize {}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
#[repr(u8)]
enum Type {
	S, // smaller
	L, // larger
}

fn types(t: &[impl Ord]) -> Vec<Type> { // TODO use bitvec?
	let mut res = vec![Type::S; t.len() + 1];
	if res.len() > 1 {
		res[t.len()-1] = Type::L;
		for i in (0..res.len()-2).rev() {
			res[i] = match t[i].cmp(&t[i+1]) {
				Ordering::Less => Type::S,
				Ordering::Equal => res[i+1],
				Ordering::Greater => Type::L,
			}
		}
	}
	res
}

#[inline]
fn is_lms(types: &[Type], pos: usize) -> bool {
	pos > 0 && types[pos] == Type::S && types[pos-1] == Type::L
}

#[inline]
fn buckets<'a, const TAIL: bool>(t: &[impl Value], buckets: &'a mut [usize]) -> &'a mut [usize] {
	buckets.fill(0);
	for b in t {
		buckets[b.i()] += 1;
	}
	let mut o = 1;
	for b in buckets.iter_mut() {
		o += *b;
		*b = o - if TAIL { 0 } else { *b };
	}
	buckets
}

fn make_array(t: &[impl Value], scratch: &mut [usize], sa: &mut [usize]) {
	let types = &types(t);

	lms_sort(t, types, scratch, sa,
		(0..t.len()).filter(|&i| is_lms(types, i))
	);

	let (names, n_names) = get_names(t, types, sa);

	let (summary_offsets, t1): (Vec<_>, Vec<_>) = names.into_iter()
		.enumerate()
		.filter(|a| a.1 != usize::MAX)
		.unzip();

	let mut sa1 = vec![usize::MAX; t1.len()+1];
	if t1.len() == n_names {
		sa1[0] = t1.len();
		for (i, &c) in t1.iter().enumerate() {
			sa1[c+1] = i
		}
	} else {
		make_array(&t1, &mut vec![0; n_names], &mut sa1);
	};

	lms_sort(t, types, scratch, sa,
		sa1[2..].iter().map(|&i| summary_offsets[i])
	);
}

fn lms_sort(
	t: &[impl Value],
	types: &[Type],
	scratch: &mut [usize],
	sa: &mut [usize],
	ix: impl DoubleEndedIterator<Item=usize>,
) {
	sa.fill(usize::MAX);
	sa[0] = t.len();

	let tails = buckets::<true>(t, scratch);
	for i in ix.rev() {
		debug_assert!(i > 0);
		let v = &mut tails[t[i].i()];
		*v -= 1;
		sa[*v] = i;
	}

	let heads = buckets::<false>(t, scratch);
	for i in 0..sa.len() {
		if sa[i] != usize::MAX && sa[i] != 0 && types[sa[i]-1] == Type::L {
			let v = &mut heads[t[sa[i]-1].i()];
			debug_assert!(*v > i);
			sa[*v] = sa[i] - 1;
			*v += 1;
		}
	}

	let tails = buckets::<true>(t, scratch);
	for i in (0..sa.len()).rev() {
		if sa[i] != usize::MAX && sa[i] != 0 && types[sa[i]-1] == Type::S {
			let v = &mut tails[t[sa[i]-1].i()];
			debug_assert!(*v <= i);
			*v -= 1;
			sa[*v] = sa[i] - 1;
		}
	}
}

fn get_names(t: &[impl Value], types: &[Type], sa: &[usize]) -> (Vec<usize>, usize) {
	let mut names = vec![usize::MAX; t.len()+1];
	let mut cur_name = 0;
	names[sa[0]] = cur_name;
	let mut last_offset = sa[0];
	for &offset in &sa[1..] {
		if is_lms(types, offset) {
			if !lms_equal(t, types, last_offset, offset) {
				cur_name += 1
			}
			last_offset = offset;
			names[offset] = cur_name;
		}
	}
	(names, cur_name+1)
}

fn lms_equal(t: &[impl Value], types: &[Type], a: usize, b: usize) -> bool {
	if a == t.len() || b == t.len() {
		return a == b
	}
	let mut i = 0;
	loop {
		if t[a+i] != t[b+i] {
			return false
		}
		i += 1;
		let al = is_lms(types, a+i);
		let bl = is_lms(types, b+i);
		if al || bl {
			return al && bl
		}
	}
}

#[derive(Debug, Clone)]
pub struct SuffixArray<'a, 'b, T: ?Sized> {
	text: &'a T,
	sa: Cow<'b, [usize]>,
}

pub type ByteSuffixArray<'a> = SuffixArray<'a, 'static, [u8]>;
pub type StrSuffixArray<'a> = SuffixArray<'a, 'static, str>;

impl<'a, 'b> SuffixArray<'a, 'b, [u8]> {
	pub fn new(text: &'a [u8]) -> Self {
		let mut sa = vec![0; text.len()+1];
		make_array(text, &mut [0; 256], &mut sa);
		SuffixArray { text, sa: Cow::Owned(sa) }
	}
}

impl<'a, 'b> SuffixArray<'a, 'b, str> {
	pub fn new_str(text: &'a str) -> Self {
		let mut sa = vec![0; text.len()+1];
		make_array(text.as_bytes(), &mut [0; 256], &mut sa);
		sa.retain(|a| text.is_char_boundary(*a));
		SuffixArray { text, sa: Cow::Owned(sa) }
	}
}

impl<'a, 'b, T: Text + ?Sized> SuffixArray<'a, 'b, T> {
	pub fn text(&self) -> &T {
		self.text
	}

	pub fn indices(&self) -> &[usize] {
		&self.sa
	}

	pub fn len(&self) -> usize {
		self.sa.len()
	}

	pub fn is_empty(&self) -> bool {
		self.len() == 0
	}

	pub fn find(&'b self, needle: &T) -> Self {
		let start = self.sa.partition_point(|a| self.text.suffix(*a) < needle);
		let len = self.sa[start..].partition_point(|a| self.text.suffix(*a).starts_with(needle));
		SuffixArray {
			text: self.text,
			sa: Cow::Borrowed(&self.sa[start..start+len])
		}
	}

	pub fn slices(&self) -> impl Iterator<Item=&T> {
		self.sa.iter().map(|a| self.text.suffix(*a))
	}

	pub fn retain(&mut self, mut p: impl FnMut(usize, &T) -> bool) {
		self.sa.to_mut().retain(|a| p(*a, self.text.suffix(*a)));
	}
}

mod text_trait {
	pub trait Text: Ord {
		fn suffix(&self, offset: usize) -> &Self;
		fn starts_with(&self, other: &Self) -> bool;
	}
}
use text_trait::Text;

impl Text for [u8] {
	fn suffix(&self, offset: usize) -> &Self {
		&self[offset..]
	}

	fn starts_with(&self, other: &Self) -> bool {
		self.starts_with(other)
	}
}

impl Text for str {
	fn suffix(&self, offset: usize) -> &Self {
		&self[offset..]
	}

	fn starts_with(&self, other: &Self) -> bool {
		self.starts_with(other)
	}
}

#[cfg(test)]
mod test {
	#[test]
	fn small() {
		check(b"cabbage");
		check(b"baabaabac");
		check(b"mississippi");
		check(b"abracadabra");
	}

	#[test]
	fn find() {
		let sa = super::SuffixArray::new(b"mississippi");
		assert_eq!(sa.find(b"i").slices().collect::<Vec<_>>(), [b"i" as &[u8], b"ippi", b"issippi", b"ississippi"]);
	}

	#[test]
	fn str() {
		let sa = super::SuffixArray::new_str("カタカナ");
		assert_eq!(sa.slices().collect::<Vec<_>>(), ["", "カタカナ", "カナ", "タカナ", "ナ"]);
		assert_eq!(sa.find("カ").slices().collect::<Vec<_>>(), ["カタカナ", "カナ"]);
	}

	#[test]
	fn random() {
		check(&[
			0x01, 0xE7, 0xF1, 0x38, 0xDB, 0xCA, 0x0A, 0x94, 0x33, 0x3B, 0x19, 0x19, 0x4F, 0x39, 0x61, 0x69, 0x23, 0x66, 0x2F, 0x7A, 0x76, 0xC3, 0x2A, 0x55, 0xDF, 0xAB, 0x82, 0xAF, 0x85, 0xB2, 0x92, 0x5B, 0xB6, 0x2E, 0x98, 0x65, 0x85, 0x30, 0xE7, 0x32, 0x7E, 0xC5, 0x6B, 0xBE, 0xC3, 0x8B, 0xE1, 0x46, 0x38, 0xAC, 0xC8, 0xBB, 0x31, 0x17, 0x94, 0xF3, 0xB6, 0xE9, 0x54, 0x36, 0x6B, 0x94, 0xA5, 0xC5,
			0x34, 0xF2, 0xE9, 0x39, 0x09, 0xD9, 0xC4, 0x96, 0x98, 0x04, 0x71, 0xAD, 0x1A, 0xB8, 0xDA, 0x72, 0xBB, 0x54, 0x32, 0x6D, 0x42, 0xCE, 0xA3, 0x0B, 0xCF, 0x41, 0x35, 0x7B, 0x38, 0x0E, 0x20, 0x4C, 0x4F, 0xA9, 0xED, 0x2E, 0x84, 0x59, 0x78, 0xD8, 0x1F, 0xBE, 0x6F, 0xCE, 0x86, 0xBE, 0x34, 0x90, 0xE1, 0x78, 0x9E, 0x99, 0x04, 0xE1, 0xF5, 0x49, 0x09, 0x95, 0x0E, 0x9F, 0x07, 0x9C, 0xCF, 0xB3,
			0xA2, 0x35, 0x39, 0x1B, 0x7A, 0x06, 0xF4, 0x3C, 0x3D, 0xCA, 0xBA, 0x93, 0x99, 0x05, 0x1A, 0x34, 0x03, 0x87, 0xF3, 0xDA, 0x4F, 0xE0, 0x0E, 0x58, 0x2B, 0x67, 0x2E, 0xEE, 0xA7, 0x97, 0xAF, 0x18, 0x77, 0x33, 0x4E, 0x24, 0xB2, 0x2A, 0x32, 0xF3, 0x19, 0x7D, 0x92, 0xDF, 0x13, 0xB0, 0x9C, 0x02, 0x81, 0xDA, 0xF2, 0x2C, 0x0B, 0xA1, 0x06, 0x23, 0x8E, 0x35, 0x75, 0x21, 0x97, 0x5D, 0xBC, 0xBA,
			0xFF, 0x9D, 0x84, 0x8F, 0xAB, 0x8C, 0xA6, 0xDE, 0xFD, 0xA2, 0xBE, 0xA2, 0x54, 0x06, 0x82, 0xE9, 0xDE, 0x67, 0x57, 0x95, 0xAB, 0x53, 0x0A, 0x87, 0x7F, 0x63, 0xD3, 0xEF, 0x60, 0xB3, 0x34, 0x06, 0x1B, 0xB2, 0x32, 0xF2, 0xC5, 0xEF, 0xC0, 0xEB, 0x62, 0x06, 0xF1, 0xE3, 0x99, 0xB3, 0x2B, 0x3D, 0x3F, 0xD9, 0x8A, 0x97, 0x61, 0xAF, 0x9E, 0x31, 0x8C, 0x58, 0xAE, 0xFC, 0x71, 0x40, 0xC2, 0x96,
			0xA7, 0xFE, 0xB3, 0xDA, 0x29, 0xAB, 0x3B, 0xB5, 0xA5, 0xDB, 0x90, 0x28, 0xB6, 0x0D, 0x8F, 0x01, 0xAE, 0x28, 0xB0, 0x0D, 0x27, 0x8B, 0xF4, 0xFB, 0x27, 0xAF, 0xB7, 0x70, 0xBA, 0x98, 0x81, 0x45, 0xE3, 0x6E, 0x9E, 0x95, 0x4B, 0xF4, 0x32, 0xDF, 0x34, 0x68, 0xFA, 0x22, 0xA6, 0x7F, 0x10, 0xD7, 0xF9, 0xCA, 0x48, 0xAE, 0x25, 0x9D, 0x14, 0x4E, 0xE2, 0x8F, 0xEF, 0x46, 0x2E, 0xC7, 0xE2, 0x49,
			0x4F, 0x64, 0x0A, 0xFD, 0x87, 0xE1, 0x48, 0xFE, 0x3E, 0xC3, 0x30, 0x14, 0xCF, 0xF6, 0xD5, 0xC3, 0x45, 0x76, 0x13, 0x87, 0x1C, 0x7F, 0xA4, 0x60, 0xD3, 0x51, 0xC4, 0x90, 0xFA, 0x06, 0x4E, 0x5E, 0x4E, 0x72, 0x99, 0xBC, 0x96, 0x7A, 0xA1, 0xF8, 0x39, 0xE6, 0x20, 0x8B, 0xD8, 0x3E, 0x85, 0xF7, 0x91, 0x8C, 0xF0, 0x14, 0xD5, 0x21, 0x08, 0x4B, 0x37, 0xD7, 0x77, 0x4D, 0x4F, 0x09, 0x7A, 0x04,
			0xBF, 0xDA, 0x12, 0x41, 0xE4, 0xBF, 0xF9, 0x40, 0xD4, 0x65, 0x21, 0x4E, 0xB7, 0x7D, 0x56, 0x26, 0xB2, 0xDD, 0xBB, 0xAA, 0x55, 0xD8, 0x6F, 0xA6, 0x5F, 0x64, 0x4B, 0x47, 0x2A, 0x2B, 0xA3, 0xD4, 0x32, 0x9B, 0x46, 0x6E, 0xD5, 0x93, 0xB5, 0xB8, 0x88, 0xA6, 0xF6, 0x71, 0xD3, 0x6A, 0xC8, 0xCF, 0xE0, 0xEB, 0x81, 0xC8, 0x04, 0xEF, 0xBB, 0x06, 0x19, 0x00, 0xB9, 0xB2, 0x01, 0xB6, 0x6E, 0x46,
			0x3C, 0x6D, 0x93, 0x90, 0x78, 0x1B, 0xAA, 0x81, 0x73, 0x14, 0x28, 0x3E, 0xF6, 0x6B, 0xBF, 0x1E, 0x96, 0xD4, 0xBA, 0x8F, 0xB4, 0x58, 0x2E, 0x28, 0x92, 0x5A, 0xED, 0x8B, 0x3D, 0xAE, 0xCF, 0xB7, 0xF5, 0xFA, 0x3E, 0x07, 0x42, 0x04, 0xBA, 0x10, 0xA2, 0x66, 0xCF, 0xFB, 0xF8, 0x83, 0x1C, 0x65, 0x91, 0x1E, 0xDF, 0xC5, 0x86, 0x65, 0x52, 0xF5, 0x54, 0x8E, 0xBD, 0x44, 0xDA, 0x6A, 0x8D, 0x0E,
			0x08, 0xBA, 0xA2, 0xF6, 0xF8, 0x0C, 0x10, 0x5A, 0x1F, 0x1D, 0x83, 0x2E, 0x7C, 0xD1, 0x46, 0x7C, 0x4F, 0xB8, 0x88, 0xE6, 0x32, 0xE2, 0xB8, 0xF3, 0xF6, 0x66, 0x88, 0x3D, 0x70, 0xEB, 0xF2, 0xEF, 0xE0, 0x02, 0xEE, 0x0B, 0x50, 0xE5, 0xEB, 0x2E, 0xE1, 0x1C, 0xBD, 0x21, 0x76, 0xBA, 0x9B, 0xB4, 0x15, 0xD2, 0xE9, 0x38, 0xBE, 0x7A, 0x9F, 0x52, 0xBC, 0xA9, 0xD8, 0xEB, 0x56, 0x19, 0xD8, 0xA2,
			0x3E, 0x0E, 0x24, 0x45, 0xE3, 0x52, 0x01, 0xEA, 0x72, 0x8A, 0x8F, 0x86, 0xD5, 0x6A, 0xE5, 0x1C, 0x28, 0x31, 0x7C, 0x36, 0x7E, 0xAC, 0x15, 0x2A, 0xE9, 0x23, 0x6D, 0x42, 0xE7, 0x39, 0x0E, 0xC9, 0xD7, 0xB3, 0x69, 0x7D, 0x78, 0xEE, 0x18, 0x07, 0xF4, 0xDD, 0xD1, 0x09, 0x86, 0x2F, 0xBC, 0x73, 0xE3, 0x08, 0x03, 0xB0, 0xDF, 0xC8, 0x1C, 0xA3, 0x22, 0x6F, 0x9A, 0xD3, 0xDE, 0x68, 0xC8, 0xD3,
			0xD3, 0x43, 0xED, 0x69, 0x63, 0x23, 0xC3, 0xE6, 0x8F, 0x6B, 0x61, 0x55, 0xB3, 0xAA, 0x99, 0x3A, 0x41, 0xEC, 0xFC, 0x4B, 0x8A, 0x3A, 0x0D, 0xBE, 0x65, 0xF8, 0x3D, 0xF6, 0x2A, 0xF0, 0xC7, 0x53, 0xB7, 0x21, 0x47, 0x19, 0xC6, 0x01, 0xD5, 0x5A, 0x2A, 0x9E, 0xE5, 0xB0, 0xDF, 0x8D, 0x99, 0xDE, 0x0C, 0x6E, 0x75, 0xAA, 0x8C, 0xEA, 0x6D, 0xC5, 0x9C, 0x8F, 0x18, 0x43, 0xDA, 0x10, 0x7F, 0x86,
			0xF5, 0xAC, 0xDF, 0x2F, 0x20, 0x54, 0xB5, 0x39, 0x67, 0x25, 0x7E, 0xD6, 0x4C, 0xED, 0x87, 0x40, 0x01, 0x61, 0xD1, 0x14, 0x1F, 0xA8, 0xA8, 0x16, 0x53, 0x52, 0xC6, 0x0F, 0xA0, 0x46, 0x4F, 0xEA, 0xF9, 0xF6, 0x76, 0x5A, 0x53, 0x40, 0x8F, 0x61, 0xE3, 0x92, 0x1B, 0xB5, 0x86, 0xAD, 0x4E, 0xD7, 0xEA, 0x02, 0x9D, 0x0A, 0x82, 0x7C, 0x00, 0x3B, 0xFE, 0x26, 0xEA, 0x16, 0x29, 0x3C, 0x10, 0x9F,
			0x76, 0x4E, 0x2A, 0x56, 0x4F, 0xD3, 0x9F, 0xE1, 0xD9, 0x8F, 0xDC, 0x56, 0x8B, 0xCE, 0x48, 0xED, 0x05, 0x45, 0xD4, 0x87, 0x0C, 0x28, 0x4B, 0xB0, 0x9F, 0xEF, 0xC8, 0xC8, 0xBE, 0x62, 0x71, 0x2D, 0x6D, 0x66, 0xF9, 0xDC, 0xF4, 0x87, 0x92, 0x80, 0xB6, 0x39, 0x65, 0x75, 0x2B, 0xDD, 0xE9, 0xCA, 0x47, 0x71, 0x89, 0x61, 0xAF, 0x32, 0x40, 0x65, 0xF4, 0x22, 0x01, 0x0C, 0x93, 0x06, 0x1E, 0x0C,
			0x24, 0x68, 0x97, 0xFD, 0xEF, 0xD0, 0x81, 0xBD, 0x1F, 0x70, 0xDA, 0x6D, 0xDE, 0xA1, 0x58, 0xDD, 0x92, 0x10, 0xCC, 0x01, 0xF7, 0x0F, 0x28, 0x1B, 0xB4, 0x92, 0xCE, 0x98, 0xF1, 0x0B, 0x09, 0xA5, 0xC9, 0x27, 0x75, 0x85, 0x79, 0xB2, 0x2E, 0x3F, 0x29, 0x7A, 0xD4, 0x73, 0xA5, 0x7F, 0x60, 0x00, 0xF7, 0x05, 0xAB, 0xB5, 0x7D, 0xE0, 0x26, 0x58, 0x2F, 0xE7, 0x15, 0x5A, 0xED, 0x40, 0xB8, 0x8F,
			0x08, 0x40, 0xEE, 0x9A, 0x09, 0xD6, 0x0D, 0x93, 0x2D, 0xA3, 0xC0, 0xAD, 0x15, 0x73, 0x84, 0x47, 0x59, 0x60, 0x45, 0x24, 0x82, 0x91, 0xE2, 0xD2, 0xB8, 0xED, 0x5F, 0xFB, 0x0E, 0x19, 0xFB, 0x1D, 0x53, 0x47, 0xBC, 0x58, 0x8D, 0x5D, 0x26, 0x83, 0x2F, 0x94, 0x4A, 0x7C, 0x61, 0x68, 0x37, 0x4F, 0x19, 0x0C, 0x2F, 0xB1, 0xE2, 0xAB, 0x9B, 0x66, 0x07, 0xB1, 0x76, 0x87, 0x83, 0x94, 0xEB, 0xE0,
			0xBB, 0xE9, 0x7B, 0xCF, 0x32, 0xFF, 0xAD, 0x30, 0xFB, 0xF1, 0x0B, 0xA4, 0x22, 0x65, 0x2B, 0xBF, 0xC3, 0x8E, 0x63, 0x30, 0xD2, 0x13, 0x11, 0xAD, 0x37, 0x2E, 0xC4, 0x6A, 0x6B, 0x26, 0x00, 0x32, 0xB8, 0x84, 0x1F, 0x0B, 0x38, 0x8B, 0x17, 0x69, 0x4E, 0x67, 0x14, 0x94, 0x96, 0x5D, 0x23, 0x3C, 0xCD, 0xD0, 0xD8, 0xA0, 0xDA, 0x28, 0x20, 0x6F, 0xBE, 0x48, 0xF5, 0x07, 0x7D, 0x36, 0xD7, 0xD2,
		]);
	}

	#[test]
	fn myself() {
		check(include_bytes!("suffix.rs"));
	}

	fn check(arg: &[u8]) {
		let sa = super::SuffixArray::new(arg);
		for (a, b) in sa.slices().zip(sa.slices().skip(1)) {
			assert!(a < b);
		}
	}
}
