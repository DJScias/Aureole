#![allow(unused)]
// Made according to this guide https://zork.net/~st/jottings/sais.html
use std::{cmp::Ordering, marker::PhantomData};

#[derive(Debug)]
pub struct SuffixArray<'a, T: ?Sized> {
	text: &'a [u8],
	sa: Vec<usize>,
	_ph: PhantomData<T>,
}

#[derive(Debug)]
pub struct SuffixArrayRef<'a, 'b, T: ?Sized> {
	text: &'a [u8],
	sa: &'b [usize],
	offset: usize,
	_ph: PhantomData<T>,
}

// Need manual impl here or it will require `T: Clone`
impl<'a, T: ?Sized> Clone for SuffixArray<'a, T> {
	fn clone(&self) -> Self {
		Self { text: self.text, sa: self.sa.clone(), _ph: PhantomData }
	}
}

impl<'a, 'b, T: ?Sized> Clone for SuffixArrayRef<'a, 'b, T> {
	fn clone(&self) -> Self {
		*self
	}
}

impl<'a, 'b, T: ?Sized> Copy for SuffixArrayRef<'a, 'b, T> {}

pub type ByteSuffixArray<'a> = SuffixArray<'a, [u8]>;
pub type StrSuffixArray<'a> = SuffixArray<'a, str>;

macro_rules! common {
	() => {
		pub fn text(&self) -> &T {
			T::from_bytes(self.text, 0)
		}

		pub fn len(&self) -> usize {
			self.sa.len()
		}

		pub fn is_empty(&self) -> bool {
			self.len() == 0
		}

		pub fn first_index(&self) -> Option<usize> {
			self.sa.first().map(|a| self.offset() + *a)
		}

		pub fn last_index(&self) -> Option<usize> {
			self.sa.last().map(|a| self.offset() + *a)
		}

		pub fn indices(&self) -> impl Iterator<Item=usize> + '_ {
			self.sa.iter().map(|a| self.offset() + *a)
		}

		pub fn first_suffix(&self) -> Option<&'a T> {
			self.sa.first().map(|a| self.get_t(*a))
		}

		pub fn last_suffix(&self) -> Option<&'a T> {
			self.sa.last().map(|a| self.get_t(*a))
		}

		pub fn suffixes(&self) -> impl Iterator<Item=&'a T> + '_ {
			self.sa.iter().map(|a| self.get_t(*a))
		}

		fn get(&self, n: usize) -> &'a [u8] {
			unsafe { &self.text.get_unchecked(self.offset()+n..) }
		}

		fn get_t(&self, n: usize) -> &'a T {
			T::from_bytes(self.text, self.offset()+n)
		}
	}
}

impl<'a, T: Text + ?Sized> SuffixArray<'a, T> {
	pub fn new(text: &'a T) -> Self {
		let text = T::as_bytes(text);
		let mut sa = vec![0; text.len()];
		divsufsort::sort_in_place(text, &mut sa);
		let sa = sa.into_iter()
			.map(|a| a as usize)
			.filter(|a| T::is_index(text, *a))
			.collect();
		SuffixArray { text, sa, _ph: PhantomData }
	}

	common!();

	fn offset(&self) -> usize {
		0
	}

	pub fn as_ref<'b>(&'b self) -> SuffixArrayRef<'a, 'b, T> {
		SuffixArrayRef {
			text: self.text,
			sa: &self.sa,
			offset: self.offset(),
			_ph: PhantomData,
		}
	}

	pub fn find<'b>(&'b self, needle: &T) -> SuffixArrayRef<'a, 'b, T> {
		self.as_ref().find(needle)
	}

	pub fn retain(&mut self, mut p: impl FnMut(usize, &T) -> bool) {
		self.sa.retain(|a| p(*a, T::from_bytes(self.text, *a)));
	}
}

impl<'a, 'b, T: Text + ?Sized> SuffixArrayRef<'a, 'b, T> {
	common!();

	pub fn offset(&self) -> usize {
		self.offset
	}

	pub fn back(&self, n: usize) -> Self {
		assert!(T::is_index(self.text, self.offset() - n));
		SuffixArrayRef {
			text: self.text,
			sa: self.sa,
			offset: self.offset() - n,
			_ph: PhantomData,
		}
	}

	pub fn advance(&self, n: usize) -> Self {
		if self.is_empty() {
			return *self
		}
		let first = self.get(*self.sa.first().unwrap());
		let last = self.get(*self.sa.last().unwrap());
		let n = first.iter().zip(last.iter())
			.take(n).take_while(|a| a.0 == a.1).count();
		SuffixArrayRef {
			text: self.text,
			sa: self.sa,
			offset: self.offset() + n,
			_ph: PhantomData,
		}
	}

	pub fn advance_on(&self, text: &T) -> Self {
		if self.is_empty() {
			return *self
		}
		let text = T::as_bytes(text);
		let first = self.get(*self.sa.first().unwrap());
		let last = self.get(*self.sa.last().unwrap());
		let n = first.iter().zip(last.iter()).zip(text.iter())
			.take_while(|a| a.0.0 == a.1 && a.0.1 == a.1).count();
		SuffixArrayRef {
			text: self.text,
			sa: self.sa,
			offset: self.offset() + n,
			_ph: PhantomData,
		}
	}

	pub fn full(&self) -> Self {
		self.back(self.offset())
	}

	pub fn to_owned(self) -> SuffixArray<'a, T> {
		SuffixArray {
			text: self.text,
			sa: self.sa.iter().map(|a| *a + self.offset()).collect(),
			_ph: PhantomData,
		}
	}

	pub fn find(&self, needle: &T) -> Self {
		let needle = T::as_bytes(needle);
		let start = self.sa.partition_point(|a| self.get(*a) < needle);
		let len = self.sa[start..].partition_point(|a| self.get(*a).starts_with(needle));
		SuffixArrayRef {
			text: self.text,
			sa: &self.sa[start..start+len],
			offset: self.offset() + needle.len(),
			_ph: PhantomData,
		}
	}
}

mod private {
	pub trait Text: Ord {
		fn is_index(v: &[u8], pos: usize) -> bool;
		fn as_bytes(v: &Self) -> &[u8];
		fn from_bytes(v: &[u8], start: usize) -> &Self;
	}
}
use private::Text;

impl Text for [u8] {
	fn is_index(_v: &[u8], _pos: usize) -> bool {
		true
	}

	fn as_bytes(v: &Self) -> &[u8] {
		v
	}

	fn from_bytes(v: &[u8], start: usize) -> &Self {
		unsafe { v.get_unchecked(start..) }
	}
}

impl Text for str {
	fn is_index(v: &[u8], pos: usize) -> bool {
		// Copied from str::is_char_boundary, but works directly on the [u8]
		if pos == 0 {
			return true;
		}

		match v.get(pos) {
			None => pos == v.len(),
			Some(&b) => (b as i8) >= -0x40,
		}
	}

	fn as_bytes(v: &Self) -> &[u8] {
		v.as_bytes()
	}

	fn from_bytes(v: &[u8], start: usize) -> &Self {
		debug_assert!(Self::is_index(v, start));
		unsafe {
			std::str::from_utf8_unchecked(v.get_unchecked(start..))
		}
	}
}

#[cfg(test)]
mod test {
	#[test]
	fn small() {
		check(b"cabbage");
		check(b"baabaabac");
		check(b"mississippi");
		check(b"abracadabra");
	}

	#[test]
	fn find() {
		let sa = super::SuffixArray::new(b"mississippi" as &[u8]);
		assert_eq!(sa.find(b"i").suffixes().collect::<Vec<_>>(), [b"" as &[u8], b"ppi", b"ssippi", b"ssissippi"]);
		assert_eq!(sa.find(b"i").full().suffixes().collect::<Vec<_>>(), [b"i" as &[u8], b"ippi", b"issippi", b"ississippi"]);
	}

	#[test]
	fn str() {
		let sa = super::SuffixArray::new("カタカナ");
		assert_eq!(sa.suffixes().collect::<Vec<_>>(), ["", "カタカナ", "カナ", "タカナ", "ナ"]);
		assert_eq!(sa.find("カ").suffixes().collect::<Vec<_>>(), ["タカナ", "ナ"]);
		assert_eq!(sa.find("カ").full().suffixes().collect::<Vec<_>>(), ["カタカナ", "カナ"]);
	}

	#[test]
	fn random() {
		check(&[
			0x01, 0xE7, 0xF1, 0x38, 0xDB, 0xCA, 0x0A, 0x94, 0x33, 0x3B, 0x19, 0x19, 0x4F, 0x39, 0x61, 0x69, 0x23, 0x66, 0x2F, 0x7A, 0x76, 0xC3, 0x2A, 0x55, 0xDF, 0xAB, 0x82, 0xAF, 0x85, 0xB2, 0x92, 0x5B, 0xB6, 0x2E, 0x98, 0x65, 0x85, 0x30, 0xE7, 0x32, 0x7E, 0xC5, 0x6B, 0xBE, 0xC3, 0x8B, 0xE1, 0x46, 0x38, 0xAC, 0xC8, 0xBB, 0x31, 0x17, 0x94, 0xF3, 0xB6, 0xE9, 0x54, 0x36, 0x6B, 0x94, 0xA5, 0xC5,
			0x34, 0xF2, 0xE9, 0x39, 0x09, 0xD9, 0xC4, 0x96, 0x98, 0x04, 0x71, 0xAD, 0x1A, 0xB8, 0xDA, 0x72, 0xBB, 0x54, 0x32, 0x6D, 0x42, 0xCE, 0xA3, 0x0B, 0xCF, 0x41, 0x35, 0x7B, 0x38, 0x0E, 0x20, 0x4C, 0x4F, 0xA9, 0xED, 0x2E, 0x84, 0x59, 0x78, 0xD8, 0x1F, 0xBE, 0x6F, 0xCE, 0x86, 0xBE, 0x34, 0x90, 0xE1, 0x78, 0x9E, 0x99, 0x04, 0xE1, 0xF5, 0x49, 0x09, 0x95, 0x0E, 0x9F, 0x07, 0x9C, 0xCF, 0xB3,
			0xA2, 0x35, 0x39, 0x1B, 0x7A, 0x06, 0xF4, 0x3C, 0x3D, 0xCA, 0xBA, 0x93, 0x99, 0x05, 0x1A, 0x34, 0x03, 0x87, 0xF3, 0xDA, 0x4F, 0xE0, 0x0E, 0x58, 0x2B, 0x67, 0x2E, 0xEE, 0xA7, 0x97, 0xAF, 0x18, 0x77, 0x33, 0x4E, 0x24, 0xB2, 0x2A, 0x32, 0xF3, 0x19, 0x7D, 0x92, 0xDF, 0x13, 0xB0, 0x9C, 0x02, 0x81, 0xDA, 0xF2, 0x2C, 0x0B, 0xA1, 0x06, 0x23, 0x8E, 0x35, 0x75, 0x21, 0x97, 0x5D, 0xBC, 0xBA,
			0xFF, 0x9D, 0x84, 0x8F, 0xAB, 0x8C, 0xA6, 0xDE, 0xFD, 0xA2, 0xBE, 0xA2, 0x54, 0x06, 0x82, 0xE9, 0xDE, 0x67, 0x57, 0x95, 0xAB, 0x53, 0x0A, 0x87, 0x7F, 0x63, 0xD3, 0xEF, 0x60, 0xB3, 0x34, 0x06, 0x1B, 0xB2, 0x32, 0xF2, 0xC5, 0xEF, 0xC0, 0xEB, 0x62, 0x06, 0xF1, 0xE3, 0x99, 0xB3, 0x2B, 0x3D, 0x3F, 0xD9, 0x8A, 0x97, 0x61, 0xAF, 0x9E, 0x31, 0x8C, 0x58, 0xAE, 0xFC, 0x71, 0x40, 0xC2, 0x96,
			0xA7, 0xFE, 0xB3, 0xDA, 0x29, 0xAB, 0x3B, 0xB5, 0xA5, 0xDB, 0x90, 0x28, 0xB6, 0x0D, 0x8F, 0x01, 0xAE, 0x28, 0xB0, 0x0D, 0x27, 0x8B, 0xF4, 0xFB, 0x27, 0xAF, 0xB7, 0x70, 0xBA, 0x98, 0x81, 0x45, 0xE3, 0x6E, 0x9E, 0x95, 0x4B, 0xF4, 0x32, 0xDF, 0x34, 0x68, 0xFA, 0x22, 0xA6, 0x7F, 0x10, 0xD7, 0xF9, 0xCA, 0x48, 0xAE, 0x25, 0x9D, 0x14, 0x4E, 0xE2, 0x8F, 0xEF, 0x46, 0x2E, 0xC7, 0xE2, 0x49,
			0x4F, 0x64, 0x0A, 0xFD, 0x87, 0xE1, 0x48, 0xFE, 0x3E, 0xC3, 0x30, 0x14, 0xCF, 0xF6, 0xD5, 0xC3, 0x45, 0x76, 0x13, 0x87, 0x1C, 0x7F, 0xA4, 0x60, 0xD3, 0x51, 0xC4, 0x90, 0xFA, 0x06, 0x4E, 0x5E, 0x4E, 0x72, 0x99, 0xBC, 0x96, 0x7A, 0xA1, 0xF8, 0x39, 0xE6, 0x20, 0x8B, 0xD8, 0x3E, 0x85, 0xF7, 0x91, 0x8C, 0xF0, 0x14, 0xD5, 0x21, 0x08, 0x4B, 0x37, 0xD7, 0x77, 0x4D, 0x4F, 0x09, 0x7A, 0x04,
			0xBF, 0xDA, 0x12, 0x41, 0xE4, 0xBF, 0xF9, 0x40, 0xD4, 0x65, 0x21, 0x4E, 0xB7, 0x7D, 0x56, 0x26, 0xB2, 0xDD, 0xBB, 0xAA, 0x55, 0xD8, 0x6F, 0xA6, 0x5F, 0x64, 0x4B, 0x47, 0x2A, 0x2B, 0xA3, 0xD4, 0x32, 0x9B, 0x46, 0x6E, 0xD5, 0x93, 0xB5, 0xB8, 0x88, 0xA6, 0xF6, 0x71, 0xD3, 0x6A, 0xC8, 0xCF, 0xE0, 0xEB, 0x81, 0xC8, 0x04, 0xEF, 0xBB, 0x06, 0x19, 0x00, 0xB9, 0xB2, 0x01, 0xB6, 0x6E, 0x46,
			0x3C, 0x6D, 0x93, 0x90, 0x78, 0x1B, 0xAA, 0x81, 0x73, 0x14, 0x28, 0x3E, 0xF6, 0x6B, 0xBF, 0x1E, 0x96, 0xD4, 0xBA, 0x8F, 0xB4, 0x58, 0x2E, 0x28, 0x92, 0x5A, 0xED, 0x8B, 0x3D, 0xAE, 0xCF, 0xB7, 0xF5, 0xFA, 0x3E, 0x07, 0x42, 0x04, 0xBA, 0x10, 0xA2, 0x66, 0xCF, 0xFB, 0xF8, 0x83, 0x1C, 0x65, 0x91, 0x1E, 0xDF, 0xC5, 0x86, 0x65, 0x52, 0xF5, 0x54, 0x8E, 0xBD, 0x44, 0xDA, 0x6A, 0x8D, 0x0E,
			0x08, 0xBA, 0xA2, 0xF6, 0xF8, 0x0C, 0x10, 0x5A, 0x1F, 0x1D, 0x83, 0x2E, 0x7C, 0xD1, 0x46, 0x7C, 0x4F, 0xB8, 0x88, 0xE6, 0x32, 0xE2, 0xB8, 0xF3, 0xF6, 0x66, 0x88, 0x3D, 0x70, 0xEB, 0xF2, 0xEF, 0xE0, 0x02, 0xEE, 0x0B, 0x50, 0xE5, 0xEB, 0x2E, 0xE1, 0x1C, 0xBD, 0x21, 0x76, 0xBA, 0x9B, 0xB4, 0x15, 0xD2, 0xE9, 0x38, 0xBE, 0x7A, 0x9F, 0x52, 0xBC, 0xA9, 0xD8, 0xEB, 0x56, 0x19, 0xD8, 0xA2,
			0x3E, 0x0E, 0x24, 0x45, 0xE3, 0x52, 0x01, 0xEA, 0x72, 0x8A, 0x8F, 0x86, 0xD5, 0x6A, 0xE5, 0x1C, 0x28, 0x31, 0x7C, 0x36, 0x7E, 0xAC, 0x15, 0x2A, 0xE9, 0x23, 0x6D, 0x42, 0xE7, 0x39, 0x0E, 0xC9, 0xD7, 0xB3, 0x69, 0x7D, 0x78, 0xEE, 0x18, 0x07, 0xF4, 0xDD, 0xD1, 0x09, 0x86, 0x2F, 0xBC, 0x73, 0xE3, 0x08, 0x03, 0xB0, 0xDF, 0xC8, 0x1C, 0xA3, 0x22, 0x6F, 0x9A, 0xD3, 0xDE, 0x68, 0xC8, 0xD3,
			0xD3, 0x43, 0xED, 0x69, 0x63, 0x23, 0xC3, 0xE6, 0x8F, 0x6B, 0x61, 0x55, 0xB3, 0xAA, 0x99, 0x3A, 0x41, 0xEC, 0xFC, 0x4B, 0x8A, 0x3A, 0x0D, 0xBE, 0x65, 0xF8, 0x3D, 0xF6, 0x2A, 0xF0, 0xC7, 0x53, 0xB7, 0x21, 0x47, 0x19, 0xC6, 0x01, 0xD5, 0x5A, 0x2A, 0x9E, 0xE5, 0xB0, 0xDF, 0x8D, 0x99, 0xDE, 0x0C, 0x6E, 0x75, 0xAA, 0x8C, 0xEA, 0x6D, 0xC5, 0x9C, 0x8F, 0x18, 0x43, 0xDA, 0x10, 0x7F, 0x86,
			0xF5, 0xAC, 0xDF, 0x2F, 0x20, 0x54, 0xB5, 0x39, 0x67, 0x25, 0x7E, 0xD6, 0x4C, 0xED, 0x87, 0x40, 0x01, 0x61, 0xD1, 0x14, 0x1F, 0xA8, 0xA8, 0x16, 0x53, 0x52, 0xC6, 0x0F, 0xA0, 0x46, 0x4F, 0xEA, 0xF9, 0xF6, 0x76, 0x5A, 0x53, 0x40, 0x8F, 0x61, 0xE3, 0x92, 0x1B, 0xB5, 0x86, 0xAD, 0x4E, 0xD7, 0xEA, 0x02, 0x9D, 0x0A, 0x82, 0x7C, 0x00, 0x3B, 0xFE, 0x26, 0xEA, 0x16, 0x29, 0x3C, 0x10, 0x9F,
			0x76, 0x4E, 0x2A, 0x56, 0x4F, 0xD3, 0x9F, 0xE1, 0xD9, 0x8F, 0xDC, 0x56, 0x8B, 0xCE, 0x48, 0xED, 0x05, 0x45, 0xD4, 0x87, 0x0C, 0x28, 0x4B, 0xB0, 0x9F, 0xEF, 0xC8, 0xC8, 0xBE, 0x62, 0x71, 0x2D, 0x6D, 0x66, 0xF9, 0xDC, 0xF4, 0x87, 0x92, 0x80, 0xB6, 0x39, 0x65, 0x75, 0x2B, 0xDD, 0xE9, 0xCA, 0x47, 0x71, 0x89, 0x61, 0xAF, 0x32, 0x40, 0x65, 0xF4, 0x22, 0x01, 0x0C, 0x93, 0x06, 0x1E, 0x0C,
			0x24, 0x68, 0x97, 0xFD, 0xEF, 0xD0, 0x81, 0xBD, 0x1F, 0x70, 0xDA, 0x6D, 0xDE, 0xA1, 0x58, 0xDD, 0x92, 0x10, 0xCC, 0x01, 0xF7, 0x0F, 0x28, 0x1B, 0xB4, 0x92, 0xCE, 0x98, 0xF1, 0x0B, 0x09, 0xA5, 0xC9, 0x27, 0x75, 0x85, 0x79, 0xB2, 0x2E, 0x3F, 0x29, 0x7A, 0xD4, 0x73, 0xA5, 0x7F, 0x60, 0x00, 0xF7, 0x05, 0xAB, 0xB5, 0x7D, 0xE0, 0x26, 0x58, 0x2F, 0xE7, 0x15, 0x5A, 0xED, 0x40, 0xB8, 0x8F,
			0x08, 0x40, 0xEE, 0x9A, 0x09, 0xD6, 0x0D, 0x93, 0x2D, 0xA3, 0xC0, 0xAD, 0x15, 0x73, 0x84, 0x47, 0x59, 0x60, 0x45, 0x24, 0x82, 0x91, 0xE2, 0xD2, 0xB8, 0xED, 0x5F, 0xFB, 0x0E, 0x19, 0xFB, 0x1D, 0x53, 0x47, 0xBC, 0x58, 0x8D, 0x5D, 0x26, 0x83, 0x2F, 0x94, 0x4A, 0x7C, 0x61, 0x68, 0x37, 0x4F, 0x19, 0x0C, 0x2F, 0xB1, 0xE2, 0xAB, 0x9B, 0x66, 0x07, 0xB1, 0x76, 0x87, 0x83, 0x94, 0xEB, 0xE0,
			0xBB, 0xE9, 0x7B, 0xCF, 0x32, 0xFF, 0xAD, 0x30, 0xFB, 0xF1, 0x0B, 0xA4, 0x22, 0x65, 0x2B, 0xBF, 0xC3, 0x8E, 0x63, 0x30, 0xD2, 0x13, 0x11, 0xAD, 0x37, 0x2E, 0xC4, 0x6A, 0x6B, 0x26, 0x00, 0x32, 0xB8, 0x84, 0x1F, 0x0B, 0x38, 0x8B, 0x17, 0x69, 0x4E, 0x67, 0x14, 0x94, 0x96, 0x5D, 0x23, 0x3C, 0xCD, 0xD0, 0xD8, 0xA0, 0xDA, 0x28, 0x20, 0x6F, 0xBE, 0x48, 0xF5, 0x07, 0x7D, 0x36, 0xD7, 0xD2,
		]);
	}

	#[test]
	fn myself() {
		check(include_bytes!("suffix.rs"));
	}

	fn check(arg: &[u8]) {
		let sa = super::SuffixArray::new(arg);
		for (a, b) in sa.suffixes().zip(sa.suffixes().skip(1)) {
			assert!(a < b, "{a:?} < {b:?}");
		}
	}
}
